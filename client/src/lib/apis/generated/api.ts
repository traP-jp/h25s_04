/* tslint:disable */
/* eslint-disable */
/**
 * H25S_04 Restaurant Review API
 * API for restaurant reviews and eatery management
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base'

/**
 *
 * @export
 * @interface EateriesEateryIdReviewsGet200Response
 */
export interface EateriesEateryIdReviewsGet200Response {
  /**
   *
   * @type {Array<ReviewSummary>}
   * @memberof EateriesEateryIdReviewsGet200Response
   */
  data?: Array<ReviewSummary>
  /**
   *
   * @type {Pagination}
   * @memberof EateriesEateryIdReviewsGet200Response
   */
  pagination?: Pagination
}
/**
 *
 * @export
 * @interface EateriesGet200Response
 */
export interface EateriesGet200Response {
  /**
   *
   * @type {Array<Eatery>}
   * @memberof EateriesGet200Response
   */
  data?: Array<Eatery>
  /**
   *
   * @type {Pagination}
   * @memberof EateriesGet200Response
   */
  pagination?: Pagination
}
/**
 *
 * @export
 * @interface Eatery
 */
export interface Eatery {
  /**
   * Unique identifier for the eatery
   * @type {string}
   * @memberof Eatery
   */
  id: string
  /**
   * Name of the eatery
   * @type {string}
   * @memberof Eatery
   */
  name: string
  /**
   * Description of the eatery
   * @type {string}
   * @memberof Eatery
   */
  description: string
  /**
   * Creation timestamp
   * @type {string}
   * @memberof Eatery
   */
  createdAt: string
  /**
   * Last update timestamp
   * @type {string}
   * @memberof Eatery
   */
  updatedAt: string
}
/**
 *
 * @export
 * @interface EateryCreate
 */
export interface EateryCreate {
  /**
   * Name of the eatery
   * @type {string}
   * @memberof EateryCreate
   */
  name: string
  /**
   * Description of the eatery
   * @type {string}
   * @memberof EateryCreate
   */
  description: string
}
/**
 *
 * @export
 * @interface EateryUpdate
 */
export interface EateryUpdate {
  /**
   * Name of the eatery
   * @type {string}
   * @memberof EateryUpdate
   */
  name?: string
  /**
   * Description of the eatery
   * @type {string}
   * @memberof EateryUpdate
   */
  description?: string
}
/**
 *
 * @export
 * @interface ImageUploadResponse
 */
export interface ImageUploadResponse {
  /**
   * Unique identifier for the uploaded image
   * @type {string}
   * @memberof ImageUploadResponse
   */
  id: string
  /**
   * URL to access the uploaded image
   * @type {string}
   * @memberof ImageUploadResponse
   */
  url: string
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * Error message
   * @type {string}
   * @memberof ModelError
   */
  error: string
  /**
   * Error code
   * @type {string}
   * @memberof ModelError
   */
  code: string
  /**
   * Additional error details
   * @type {object}
   * @memberof ModelError
   */
  details?: object
}
/**
 *
 * @export
 * @interface Pagination
 */
export interface Pagination {
  /**
   * Current page number
   * @type {number}
   * @memberof Pagination
   */
  page: number
  /**
   * Number of items per page
   * @type {number}
   * @memberof Pagination
   */
  limit: number
  /**
   * Total number of items
   * @type {number}
   * @memberof Pagination
   */
  total: number
  /**
   * Total number of pages
   * @type {number}
   * @memberof Pagination
   */
  totalPages: number
}
/**
 *
 * @export
 * @interface ReviewCreate
 */
export interface ReviewCreate {
  /**
   * Content of the review
   * @type {string}
   * @memberof ReviewCreate
   */
  content: string
  /**
   * ID of the review author
   * @type {string}
   * @memberof ReviewCreate
   */
  authorId: string
  /**
   * Array of image IDs to attach to the review
   * @type {Array<string>}
   * @memberof ReviewCreate
   */
  imageIds?: Array<string>
}
/**
 * Detailed review information
 * @export
 * @interface ReviewDetail
 */
export interface ReviewDetail {
  /**
   * Unique identifier for the review
   * @type {string}
   * @memberof ReviewDetail
   */
  id: string
  /**
   * Full content of the review
   * @type {string}
   * @memberof ReviewDetail
   */
  content: string
  /**
   * ID of the review author
   * @type {string}
   * @memberof ReviewDetail
   */
  authorId: string
  /**
   * ID of the eatery being reviewed
   * @type {string}
   * @memberof ReviewDetail
   */
  eateryId: string
  /**
   * Name of the eatery being reviewed
   * @type {string}
   * @memberof ReviewDetail
   */
  eateryName: string
  /**
   * Array of image IDs attached to the review
   * @type {Array<string>}
   * @memberof ReviewDetail
   */
  imageIds: Array<string>
  /**
   * Creation timestamp
   * @type {string}
   * @memberof ReviewDetail
   */
  createdAt: string
  /**
   * Last update timestamp
   * @type {string}
   * @memberof ReviewDetail
   */
  updatedAt: string
}
/**
 * Summary of a review for list views (without full content)
 * @export
 * @interface ReviewSummary
 */
export interface ReviewSummary {
  /**
   * Unique identifier for the review
   * @type {string}
   * @memberof ReviewSummary
   */
  id: string
  /**
   * ID of the review author
   * @type {string}
   * @memberof ReviewSummary
   */
  authorId: string
  /**
   * ID of the eatery being reviewed
   * @type {string}
   * @memberof ReviewSummary
   */
  eateryId: string
  /**
   * Name of the eatery being reviewed
   * @type {string}
   * @memberof ReviewSummary
   */
  eateryName: string
  /**
   * Array of image IDs attached to the review
   * @type {Array<string>}
   * @memberof ReviewSummary
   */
  imageIds: Array<string>
  /**
   * Short summary or first few lines of the review
   * @type {string}
   * @memberof ReviewSummary
   */
  summary?: string
  /**
   * Creation timestamp
   * @type {string}
   * @memberof ReviewSummary
   */
  createdAt: string
  /**
   * Last update timestamp
   * @type {string}
   * @memberof ReviewSummary
   */
  updatedAt: string
}
/**
 *
 * @export
 * @interface ReviewUpdate
 */
export interface ReviewUpdate {
  /**
   * Content of the review
   * @type {string}
   * @memberof ReviewUpdate
   */
  content?: string
  /**
   * Array of image IDs to attach to the review
   * @type {Array<string>}
   * @memberof ReviewUpdate
   */
  imageIds?: Array<string>
}

/**
 * EateriesApi - axios parameter creator
 * @export
 */
export const EateriesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns a specific eatery by its ID
     * @summary Get eatery by ID
     * @param {string} eateryId UUID of the eatery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eateriesEateryIdGet: async (
      eateryId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'eateryId' is not null or undefined
      assertParamExists('eateriesEateryIdGet', 'eateryId', eateryId)
      const localVarPath = `/eateries/{eateryId}`.replace(
        `{${'eateryId'}}`,
        encodeURIComponent(String(eateryId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates an existing eatery\'s information
     * @summary Update eatery
     * @param {string} eateryId UUID of the eatery
     * @param {EateryUpdate} eateryUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eateriesEateryIdPut: async (
      eateryId: string,
      eateryUpdate: EateryUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'eateryId' is not null or undefined
      assertParamExists('eateriesEateryIdPut', 'eateryId', eateryId)
      // verify required parameter 'eateryUpdate' is not null or undefined
      assertParamExists('eateriesEateryIdPut', 'eateryUpdate', eateryUpdate)
      const localVarPath = `/eateries/{eateryId}`.replace(
        `{${'eateryId'}}`,
        encodeURIComponent(String(eateryId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        eateryUpdate,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of all eateries with optional query filtering
     * @summary Get list of eateries
     * @param {string} [query] Search query to filter eateries by name or description
     * @param {number} [page] Page number for pagination
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eateriesGet: async (
      query?: string,
      page?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/eateries`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Creates a new eatery
     * @summary Create a new eatery
     * @param {EateryCreate} eateryCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eateriesPost: async (
      eateryCreate: EateryCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'eateryCreate' is not null or undefined
      assertParamExists('eateriesPost', 'eateryCreate', eateryCreate)
      const localVarPath = `/eateries`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        eateryCreate,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * EateriesApi - functional programming interface
 * @export
 */
export const EateriesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EateriesApiAxiosParamCreator(configuration)
  return {
    /**
     * Returns a specific eatery by its ID
     * @summary Get eatery by ID
     * @param {string} eateryId UUID of the eatery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eateriesEateryIdGet(
      eateryId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Eatery>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eateriesEateryIdGet(eateryId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EateriesApi.eateriesEateryIdGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Updates an existing eatery\'s information
     * @summary Update eatery
     * @param {string} eateryId UUID of the eatery
     * @param {EateryUpdate} eateryUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eateriesEateryIdPut(
      eateryId: string,
      eateryUpdate: EateryUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Eatery>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eateriesEateryIdPut(
          eateryId,
          eateryUpdate,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EateriesApi.eateriesEateryIdPut']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns a list of all eateries with optional query filtering
     * @summary Get list of eateries
     * @param {string} [query] Search query to filter eateries by name or description
     * @param {number} [page] Page number for pagination
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eateriesGet(
      query?: string,
      page?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EateriesGet200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.eateriesGet(
        query,
        page,
        limit,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EateriesApi.eateriesGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Creates a new eatery
     * @summary Create a new eatery
     * @param {EateryCreate} eateryCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eateriesPost(
      eateryCreate: EateryCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Eatery>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.eateriesPost(
        eateryCreate,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EateriesApi.eateriesPost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * EateriesApi - factory interface
 * @export
 */
export const EateriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = EateriesApiFp(configuration)
  return {
    /**
     * Returns a specific eatery by its ID
     * @summary Get eatery by ID
     * @param {string} eateryId UUID of the eatery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eateriesEateryIdGet(eateryId: string, options?: any): AxiosPromise<Eatery> {
      return localVarFp
        .eateriesEateryIdGet(eateryId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates an existing eatery\'s information
     * @summary Update eatery
     * @param {string} eateryId UUID of the eatery
     * @param {EateryUpdate} eateryUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eateriesEateryIdPut(
      eateryId: string,
      eateryUpdate: EateryUpdate,
      options?: any,
    ): AxiosPromise<Eatery> {
      return localVarFp
        .eateriesEateryIdPut(eateryId, eateryUpdate, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of all eateries with optional query filtering
     * @summary Get list of eateries
     * @param {string} [query] Search query to filter eateries by name or description
     * @param {number} [page] Page number for pagination
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eateriesGet(
      query?: string,
      page?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<EateriesGet200Response> {
      return localVarFp
        .eateriesGet(query, page, limit, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Creates a new eatery
     * @summary Create a new eatery
     * @param {EateryCreate} eateryCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eateriesPost(
      eateryCreate: EateryCreate,
      options?: any,
    ): AxiosPromise<Eatery> {
      return localVarFp
        .eateriesPost(eateryCreate, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * EateriesApi - object-oriented interface
 * @export
 * @class EateriesApi
 * @extends {BaseAPI}
 */
export class EateriesApi extends BaseAPI {
  /**
   * Returns a specific eatery by its ID
   * @summary Get eatery by ID
   * @param {string} eateryId UUID of the eatery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EateriesApi
   */
  public eateriesEateryIdGet(
    eateryId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return EateriesApiFp(this.configuration)
      .eateriesEateryIdGet(eateryId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates an existing eatery\'s information
   * @summary Update eatery
   * @param {string} eateryId UUID of the eatery
   * @param {EateryUpdate} eateryUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EateriesApi
   */
  public eateriesEateryIdPut(
    eateryId: string,
    eateryUpdate: EateryUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return EateriesApiFp(this.configuration)
      .eateriesEateryIdPut(eateryId, eateryUpdate, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of all eateries with optional query filtering
   * @summary Get list of eateries
   * @param {string} [query] Search query to filter eateries by name or description
   * @param {number} [page] Page number for pagination
   * @param {number} [limit] Number of items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EateriesApi
   */
  public eateriesGet(
    query?: string,
    page?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return EateriesApiFp(this.configuration)
      .eateriesGet(query, page, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Creates a new eatery
   * @summary Create a new eatery
   * @param {EateryCreate} eateryCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EateriesApi
   */
  public eateriesPost(
    eateryCreate: EateryCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return EateriesApiFp(this.configuration)
      .eateriesPost(eateryCreate, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Downloads an image by its ID
     * @summary Download image
     * @param {string} imageId UUID of the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesImageIdGet: async (
      imageId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'imageId' is not null or undefined
      assertParamExists('imagesImageIdGet', 'imageId', imageId)
      const localVarPath = `/images/{imageId}`.replace(
        `{${'imageId'}}`,
        encodeURIComponent(String(imageId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Uploads an image file and returns its ID
     * @summary Upload image
     * @param {File} image Image file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesPost: async (
      image: File,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'image' is not null or undefined
      assertParamExists('imagesPost', 'image', image)
      const localVarPath = `/images`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      if (image !== undefined) {
        localVarFormParams.append('image', image as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
  return {
    /**
     * Downloads an image by its ID
     * @summary Download image
     * @param {string} imageId UUID of the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesImageIdGet(
      imageId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.imagesImageIdGet(imageId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ImagesApi.imagesImageIdGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Uploads an image file and returns its ID
     * @summary Upload image
     * @param {File} image Image file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesPost(
      image: File,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ImageUploadResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesPost(
        image,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ImagesApi.imagesPost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ImagesApiFp(configuration)
  return {
    /**
     * Downloads an image by its ID
     * @summary Download image
     * @param {string} imageId UUID of the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesImageIdGet(imageId: string, options?: any): AxiosPromise<File> {
      return localVarFp
        .imagesImageIdGet(imageId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Uploads an image file and returns its ID
     * @summary Upload image
     * @param {File} image Image file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesPost(image: File, options?: any): AxiosPromise<ImageUploadResponse> {
      return localVarFp
        .imagesPost(image, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
  /**
   * Downloads an image by its ID
   * @summary Download image
   * @param {string} imageId UUID of the image
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public imagesImageIdGet(imageId: string, options?: RawAxiosRequestConfig) {
    return ImagesApiFp(this.configuration)
      .imagesImageIdGet(imageId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Uploads an image file and returns its ID
   * @summary Upload image
   * @param {File} image Image file to upload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public imagesPost(image: File, options?: RawAxiosRequestConfig) {
    return ImagesApiFp(this.configuration)
      .imagesPost(image, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ReviewsApi - axios parameter creator
 * @export
 */
export const ReviewsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns all reviews for a specific eatery
     * @summary Get reviews for a specific eatery
     * @param {string} eateryId UUID of the eatery
     * @param {EateriesEateryIdReviewsGetSortByEnum} [sortBy] Sort order for reviews
     * @param {number} [page] Page number for pagination
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eateriesEateryIdReviewsGet: async (
      eateryId: string,
      sortBy?: EateriesEateryIdReviewsGetSortByEnum,
      page?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'eateryId' is not null or undefined
      assertParamExists('eateriesEateryIdReviewsGet', 'eateryId', eateryId)
      const localVarPath = `/eateries/{eateryId}/reviews`.replace(
        `{${'eateryId'}}`,
        encodeURIComponent(String(eateryId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (sortBy !== undefined) {
        localVarQueryParameter['sortBy'] = sortBy
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Creates a new review for a specific eatery
     * @summary Create a review for an eatery
     * @param {string} eateryId UUID of the eatery
     * @param {ReviewCreate} reviewCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eateriesEateryIdReviewsPost: async (
      eateryId: string,
      reviewCreate: ReviewCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'eateryId' is not null or undefined
      assertParamExists('eateriesEateryIdReviewsPost', 'eateryId', eateryId)
      // verify required parameter 'reviewCreate' is not null or undefined
      assertParamExists(
        'eateriesEateryIdReviewsPost',
        'reviewCreate',
        reviewCreate,
      )
      const localVarPath = `/eateries/{eateryId}/reviews`.replace(
        `{${'eateryId'}}`,
        encodeURIComponent(String(eateryId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        reviewCreate,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of all reviews across all eateries with images only, optimized for the top page
     * @summary Get all reviews (summary for top page)
     * @param {ReviewsGetSortByEnum} [sortBy] Sort order for reviews
     * @param {number} [page] Page number for pagination
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reviewsGet: async (
      sortBy?: ReviewsGetSortByEnum,
      page?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/reviews`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (sortBy !== undefined) {
        localVarQueryParameter['sortBy'] = sortBy
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes a specific review
     * @summary Delete review
     * @param {string} reviewId UUID of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reviewsReviewIdDelete: async (
      reviewId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'reviewId' is not null or undefined
      assertParamExists('reviewsReviewIdDelete', 'reviewId', reviewId)
      const localVarPath = `/reviews/{reviewId}`.replace(
        `{${'reviewId'}}`,
        encodeURIComponent(String(reviewId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns detailed information about a specific review
     * @summary Get review details
     * @param {string} reviewId UUID of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reviewsReviewIdGet: async (
      reviewId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'reviewId' is not null or undefined
      assertParamExists('reviewsReviewIdGet', 'reviewId', reviewId)
      const localVarPath = `/reviews/{reviewId}`.replace(
        `{${'reviewId'}}`,
        encodeURIComponent(String(reviewId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates an existing review
     * @summary Update review
     * @param {string} reviewId UUID of the review
     * @param {ReviewUpdate} reviewUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reviewsReviewIdPut: async (
      reviewId: string,
      reviewUpdate: ReviewUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'reviewId' is not null or undefined
      assertParamExists('reviewsReviewIdPut', 'reviewId', reviewId)
      // verify required parameter 'reviewUpdate' is not null or undefined
      assertParamExists('reviewsReviewIdPut', 'reviewUpdate', reviewUpdate)
      const localVarPath = `/reviews/{reviewId}`.replace(
        `{${'reviewId'}}`,
        encodeURIComponent(String(reviewId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        reviewUpdate,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ReviewsApi - functional programming interface
 * @export
 */
export const ReviewsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ReviewsApiAxiosParamCreator(configuration)
  return {
    /**
     * Returns all reviews for a specific eatery
     * @summary Get reviews for a specific eatery
     * @param {string} eateryId UUID of the eatery
     * @param {EateriesEateryIdReviewsGetSortByEnum} [sortBy] Sort order for reviews
     * @param {number} [page] Page number for pagination
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eateriesEateryIdReviewsGet(
      eateryId: string,
      sortBy?: EateriesEateryIdReviewsGetSortByEnum,
      page?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EateriesEateryIdReviewsGet200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eateriesEateryIdReviewsGet(
          eateryId,
          sortBy,
          page,
          limit,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ReviewsApi.eateriesEateryIdReviewsGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Creates a new review for a specific eatery
     * @summary Create a review for an eatery
     * @param {string} eateryId UUID of the eatery
     * @param {ReviewCreate} reviewCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eateriesEateryIdReviewsPost(
      eateryId: string,
      reviewCreate: ReviewCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewDetail>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eateriesEateryIdReviewsPost(
          eateryId,
          reviewCreate,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ReviewsApi.eateriesEateryIdReviewsPost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns a list of all reviews across all eateries with images only, optimized for the top page
     * @summary Get all reviews (summary for top page)
     * @param {ReviewsGetSortByEnum} [sortBy] Sort order for reviews
     * @param {number} [page] Page number for pagination
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async reviewsGet(
      sortBy?: ReviewsGetSortByEnum,
      page?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EateriesEateryIdReviewsGet200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsGet(
        sortBy,
        page,
        limit,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ReviewsApi.reviewsGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Deletes a specific review
     * @summary Delete review
     * @param {string} reviewId UUID of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async reviewsReviewIdDelete(
      reviewId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.reviewsReviewIdDelete(reviewId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ReviewsApi.reviewsReviewIdDelete']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns detailed information about a specific review
     * @summary Get review details
     * @param {string} reviewId UUID of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async reviewsReviewIdGet(
      reviewId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewDetail>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.reviewsReviewIdGet(reviewId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ReviewsApi.reviewsReviewIdGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Updates an existing review
     * @summary Update review
     * @param {string} reviewId UUID of the review
     * @param {ReviewUpdate} reviewUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async reviewsReviewIdPut(
      reviewId: string,
      reviewUpdate: ReviewUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewDetail>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.reviewsReviewIdPut(
          reviewId,
          reviewUpdate,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ReviewsApi.reviewsReviewIdPut']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ReviewsApi - factory interface
 * @export
 */
export const ReviewsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ReviewsApiFp(configuration)
  return {
    /**
     * Returns all reviews for a specific eatery
     * @summary Get reviews for a specific eatery
     * @param {string} eateryId UUID of the eatery
     * @param {EateriesEateryIdReviewsGetSortByEnum} [sortBy] Sort order for reviews
     * @param {number} [page] Page number for pagination
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eateriesEateryIdReviewsGet(
      eateryId: string,
      sortBy?: EateriesEateryIdReviewsGetSortByEnum,
      page?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<EateriesEateryIdReviewsGet200Response> {
      return localVarFp
        .eateriesEateryIdReviewsGet(eateryId, sortBy, page, limit, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Creates a new review for a specific eatery
     * @summary Create a review for an eatery
     * @param {string} eateryId UUID of the eatery
     * @param {ReviewCreate} reviewCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eateriesEateryIdReviewsPost(
      eateryId: string,
      reviewCreate: ReviewCreate,
      options?: any,
    ): AxiosPromise<ReviewDetail> {
      return localVarFp
        .eateriesEateryIdReviewsPost(eateryId, reviewCreate, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of all reviews across all eateries with images only, optimized for the top page
     * @summary Get all reviews (summary for top page)
     * @param {ReviewsGetSortByEnum} [sortBy] Sort order for reviews
     * @param {number} [page] Page number for pagination
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reviewsGet(
      sortBy?: ReviewsGetSortByEnum,
      page?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<EateriesEateryIdReviewsGet200Response> {
      return localVarFp
        .reviewsGet(sortBy, page, limit, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Deletes a specific review
     * @summary Delete review
     * @param {string} reviewId UUID of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reviewsReviewIdDelete(reviewId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .reviewsReviewIdDelete(reviewId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns detailed information about a specific review
     * @summary Get review details
     * @param {string} reviewId UUID of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reviewsReviewIdGet(
      reviewId: string,
      options?: any,
    ): AxiosPromise<ReviewDetail> {
      return localVarFp
        .reviewsReviewIdGet(reviewId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates an existing review
     * @summary Update review
     * @param {string} reviewId UUID of the review
     * @param {ReviewUpdate} reviewUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reviewsReviewIdPut(
      reviewId: string,
      reviewUpdate: ReviewUpdate,
      options?: any,
    ): AxiosPromise<ReviewDetail> {
      return localVarFp
        .reviewsReviewIdPut(reviewId, reviewUpdate, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ReviewsApi - object-oriented interface
 * @export
 * @class ReviewsApi
 * @extends {BaseAPI}
 */
export class ReviewsApi extends BaseAPI {
  /**
   * Returns all reviews for a specific eatery
   * @summary Get reviews for a specific eatery
   * @param {string} eateryId UUID of the eatery
   * @param {EateriesEateryIdReviewsGetSortByEnum} [sortBy] Sort order for reviews
   * @param {number} [page] Page number for pagination
   * @param {number} [limit] Number of items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewsApi
   */
  public eateriesEateryIdReviewsGet(
    eateryId: string,
    sortBy?: EateriesEateryIdReviewsGetSortByEnum,
    page?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return ReviewsApiFp(this.configuration)
      .eateriesEateryIdReviewsGet(eateryId, sortBy, page, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Creates a new review for a specific eatery
   * @summary Create a review for an eatery
   * @param {string} eateryId UUID of the eatery
   * @param {ReviewCreate} reviewCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewsApi
   */
  public eateriesEateryIdReviewsPost(
    eateryId: string,
    reviewCreate: ReviewCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return ReviewsApiFp(this.configuration)
      .eateriesEateryIdReviewsPost(eateryId, reviewCreate, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of all reviews across all eateries with images only, optimized for the top page
   * @summary Get all reviews (summary for top page)
   * @param {ReviewsGetSortByEnum} [sortBy] Sort order for reviews
   * @param {number} [page] Page number for pagination
   * @param {number} [limit] Number of items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewsApi
   */
  public reviewsGet(
    sortBy?: ReviewsGetSortByEnum,
    page?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return ReviewsApiFp(this.configuration)
      .reviewsGet(sortBy, page, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deletes a specific review
   * @summary Delete review
   * @param {string} reviewId UUID of the review
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewsApi
   */
  public reviewsReviewIdDelete(
    reviewId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ReviewsApiFp(this.configuration)
      .reviewsReviewIdDelete(reviewId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns detailed information about a specific review
   * @summary Get review details
   * @param {string} reviewId UUID of the review
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewsApi
   */
  public reviewsReviewIdGet(reviewId: string, options?: RawAxiosRequestConfig) {
    return ReviewsApiFp(this.configuration)
      .reviewsReviewIdGet(reviewId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates an existing review
   * @summary Update review
   * @param {string} reviewId UUID of the review
   * @param {ReviewUpdate} reviewUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewsApi
   */
  public reviewsReviewIdPut(
    reviewId: string,
    reviewUpdate: ReviewUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return ReviewsApiFp(this.configuration)
      .reviewsReviewIdPut(reviewId, reviewUpdate, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const EateriesEateryIdReviewsGetSortByEnum = {
  Newest: 'newest',
  Oldest: 'oldest',
} as const
export type EateriesEateryIdReviewsGetSortByEnum =
  (typeof EateriesEateryIdReviewsGetSortByEnum)[keyof typeof EateriesEateryIdReviewsGetSortByEnum]
/**
 * @export
 */
export const ReviewsGetSortByEnum = {
  Newest: 'newest',
  Oldest: 'oldest',
} as const
export type ReviewsGetSortByEnum =
  (typeof ReviewsGetSortByEnum)[keyof typeof ReviewsGetSortByEnum]

export class Apis extends BaseAPI {
  /**
   * Returns a specific eatery by its ID
   * @summary Get eatery by ID
   * @param {string} eateryId UUID of the eatery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EateriesApi
   */
  public eateriesEateryIdGet(
    eateryId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return EateriesApiFp(this.configuration)
      .eateriesEateryIdGet(eateryId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates an existing eatery\'s information
   * @summary Update eatery
   * @param {string} eateryId UUID of the eatery
   * @param {EateryUpdate} eateryUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EateriesApi
   */
  public eateriesEateryIdPut(
    eateryId: string,
    eateryUpdate: EateryUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return EateriesApiFp(this.configuration)
      .eateriesEateryIdPut(eateryId, eateryUpdate, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of all eateries with optional query filtering
   * @summary Get list of eateries
   * @param {string} [query] Search query to filter eateries by name or description
   * @param {number} [page] Page number for pagination
   * @param {number} [limit] Number of items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EateriesApi
   */
  public eateriesGet(
    query?: string,
    page?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return EateriesApiFp(this.configuration)
      .eateriesGet(query, page, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Creates a new eatery
   * @summary Create a new eatery
   * @param {EateryCreate} eateryCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EateriesApi
   */
  public eateriesPost(
    eateryCreate: EateryCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return EateriesApiFp(this.configuration)
      .eateriesPost(eateryCreate, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Downloads an image by its ID
   * @summary Download image
   * @param {string} imageId UUID of the image
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public imagesImageIdGet(imageId: string, options?: RawAxiosRequestConfig) {
    return ImagesApiFp(this.configuration)
      .imagesImageIdGet(imageId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Uploads an image file and returns its ID
   * @summary Upload image
   * @param {File} image Image file to upload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public imagesPost(image: File, options?: RawAxiosRequestConfig) {
    return ImagesApiFp(this.configuration)
      .imagesPost(image, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns all reviews for a specific eatery
   * @summary Get reviews for a specific eatery
   * @param {string} eateryId UUID of the eatery
   * @param {EateriesEateryIdReviewsGetSortByEnum} [sortBy] Sort order for reviews
   * @param {number} [page] Page number for pagination
   * @param {number} [limit] Number of items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewsApi
   */
  public eateriesEateryIdReviewsGet(
    eateryId: string,
    sortBy?: EateriesEateryIdReviewsGetSortByEnum,
    page?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return ReviewsApiFp(this.configuration)
      .eateriesEateryIdReviewsGet(eateryId, sortBy, page, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Creates a new review for a specific eatery
   * @summary Create a review for an eatery
   * @param {string} eateryId UUID of the eatery
   * @param {ReviewCreate} reviewCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewsApi
   */
  public eateriesEateryIdReviewsPost(
    eateryId: string,
    reviewCreate: ReviewCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return ReviewsApiFp(this.configuration)
      .eateriesEateryIdReviewsPost(eateryId, reviewCreate, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of all reviews across all eateries with images only, optimized for the top page
   * @summary Get all reviews (summary for top page)
   * @param {ReviewsGetSortByEnum} [sortBy] Sort order for reviews
   * @param {number} [page] Page number for pagination
   * @param {number} [limit] Number of items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewsApi
   */
  public reviewsGet(
    sortBy?: ReviewsGetSortByEnum,
    page?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return ReviewsApiFp(this.configuration)
      .reviewsGet(sortBy, page, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deletes a specific review
   * @summary Delete review
   * @param {string} reviewId UUID of the review
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewsApi
   */
  public reviewsReviewIdDelete(
    reviewId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ReviewsApiFp(this.configuration)
      .reviewsReviewIdDelete(reviewId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns detailed information about a specific review
   * @summary Get review details
   * @param {string} reviewId UUID of the review
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewsApi
   */
  public reviewsReviewIdGet(reviewId: string, options?: RawAxiosRequestConfig) {
    return ReviewsApiFp(this.configuration)
      .reviewsReviewIdGet(reviewId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates an existing review
   * @summary Update review
   * @param {string} reviewId UUID of the review
   * @param {ReviewUpdate} reviewUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewsApi
   */
  public reviewsReviewIdPut(
    reviewId: string,
    reviewUpdate: ReviewUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return ReviewsApiFp(this.configuration)
      .reviewsReviewIdPut(reviewId, reviewUpdate, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
